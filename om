-- 朝向目标（修正版）
local function lookAtTarget()
    if not config.enabled then return end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    
    local nearestPlayer, distance = getNearestPlayer()
    if not nearestPlayer then return end
    
    local targetCharacter = nearestPlayer.Character
    if not targetCharacter then return end
    
    local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetRoot then return end
    
    -- 方法1：使用Humanoid的MoveTo来间接控制朝向（最安全）
    if humanoid then
        local lookVector = (targetRoot.Position - humanoidRootPart.Position).Unit
        humanoid:MoveTo(humanoidRootPart.Position + lookVector * 0.1)
    end
    
    -- 方法2：只旋转Y轴，保持其他轴不变
    local currentCFrame = humanoidRootPart.CFrame
    local lookPosition = Vector3.new(targetRoot.Position.X, humanoidRootPart.Position.Y, targetRoot.Position.Z)
    
    if config.smoothRotation then
        -- 平滑旋转Y轴
        local currentLookVector = currentCFrame.LookVector
        local targetLookVector = (lookPosition - humanoidRootPart.Position).Unit
        
        -- 插值计算新的朝向
        local newLookVector = currentLookVector:Lerp(targetLookVector, config.rotationSpeed * config.updateInterval)
        
        -- 只应用旋转，不改变位置
        humanoidRootPart.CFrame = CFrame.new(
            humanoidRootPart.Position,
            humanoidRootPart.Position + Vector3.new(newLookVector.X, 0, newLookVector.Z)
        )
    else
        -- 直接朝向（只旋转Y轴）
        humanoidRootPart.CFrame = CFrame.new(
            humanoidRootPart.Position,
            lookPosition
        )
    end
end
